\chapter{Implementation of the Trading Systems}
This section provides a comprehensive overview of the two trading system implementations. The first one focuses on the backtesting system, which involves simulating and evaluating strategies in a controlled environment. In this system, historical market data is utilized to test and analyze the performance of various strategies. The second implementation is the live system, designed to execute trades on the Ethereum blockchain using smart contracts. This system operates in real-time and interacts with the live market, allowing for actual trades to be executed based on predefined strategies. Together, these two implementations provide a comprehensive framework for testing, evaluating, and deploying trading strategies, both in simulated environments and on the live blockchain.

\section{Backtesting System}
\label{sec:backtesting-sys}

To develop a resilient backtesting system, a dedicated class was constructed to streamline the process of testing trading strategies, the system is entirely written in Python as it possesses countless libraries including Pandas and Numpy which are extensively used to data manipulation and analysis, it also is good with integrating with many data sources such as GraphQL which is required for this project. To evaluate a particular strategy, the \texttt{backtest} function requires \texttt{cointegrated\_pair}, a tuple of the names of the liquidity pools that the strategy is to be evaluated on, \texttt{strategy}, the strategy, and finally, the \texttt{initial\_investment} in ETH. The first argument is required and used to retrieve the relevant historical prices. The second parameter is self-explanatory, the strategy to test. Finally, the inclusion of the initial investment amount as an input parameter enables users to simulate the performance of their strategies with a specific starting capital, it also helps analyze how the various transaction costs affect the ability to trade if any trades do result in a loss. The \texttt{backtest} function iterates through historical data calling the strategy's \texttt{generate\_signal} and executing the trade orders it receives at each timestep. However, to do this historical data is required hence, the first step is to collect the historical data. The logical process of backtesting a pair can be seen in Figure \ref{fig:backtesting-flow}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{project/Images/backtesting-diagram.png}
    \caption{Flowchart of backtesting a strategy on a liquidity pool pair \label{fig:backtesting-flow}}
\end{figure}

\subsection{Data Collection and Storage}
In order to simulate the market as accurately as possible the system should have access to reliable and accurate historical market data, including price, volume, and other relevant indicators. Therefore, I retrieve all of my data from the Uniswap and Aave protocols' subgraph using the Graph~\cite{noauthor_graph_nodate}. The Graph is a decentralised protocol for indexing and querying blockchain data hence making the data provided 100\% reliable as it indexes directly on the Ethereum blockchain. Subgraphs serve as GraphQL APIs designed to facilitate querying and extracting data from the blockchain. These APIs adhere to a specific schema outlined by the protocol, enabling seamless communication between the protocol and the underlying blockchain. Therefore, I employ the Uniswap V3, Aave V2, and Aave V3 subgraphs to obtain the data required for the backtesting system.
\\[3mm]
To store the necessary data for backtesting and trading, a PostgreSQL database is used this is to provide consistency, flexibility with numerous data types and also supports a large set of SQL functions that allow for advanced querying. The database adopts the following schema:
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.8\textwidth]{project/Images/database_tables.png}
    \caption{Tables contained in the database \label{fig:database}}
\end{figure}
\\[3mm]
The \texttt{liquidity\_pools} contains data about the liquidity pools that exist on Uniswap V3. After obtaining all of the data it is found that it possesses 12,182 liquidity pools. However, a substantial portion of these pools exhibit minimal or negligible trading volume. As a result, a criterion is established to selectively include only those liquidity pools that involve tokens supported by Aave and possess a trading volume exceeding \$10,000,000 (or \$10 million). This filtering condition ensures that the collected and stored data holds significance and relevance for research purposes, as these pools would allow for short selling.
\\[3mm]
Once these pools have been identified, pricing data about each pool that meets this condition is collected again using the Uniswap V3 subgraph. The query returns an array of dictionaries containing the pre-specified pricing datapoints at a frequency of every hour. Due to the limitations imposed by the subgraph, the results are constrained to a maximum size of 1000 entries. To overcome this limitation and obtain the complete dataset, the query is executed iteratively. The previous maximum time, referred to as \texttt{prev\_max\_time}, is passed as an argument in subsequent queries to fetch the remaining data, i.e. \texttt{prev\_max\_time = hourlyData[-1]['periodStartUnix'] if len(hourlyData) > 0 else prev\_max\_time}. This data is stored in tables of the form \textit{<pool\_address>}\_\textit{<token0>}\_\textit{<token1>}.
\\[3mm]
In a similar manner, obtaining the interest rates for borrowing necessitates the utilization of two of Aave's subgraphs. This requirement arises due to Aave's migration to Version 3 in March 2022, resulting in a transitional period where both Uniswap V3 and Aave V2 were concurrently utilized. The schemas for the two are different, however for the data we require, the borrowing rate, loan-to-value and liquidity threshold, the schema is consistent and the same query can be used, this can be seen in Appendix \ref{app:lending-query}. During the table initialization process, requests are made to both the V2 and V3 GraphQL endpoints. However, when updating the table, only the V3 endpoint is utilized for sending requests. The data is stored in tables of the form \textit{<symbol>}\_borrowing\_rates, where \textit{<symbol>} are all of the tokens that are present in the liquidity pools that are of interest.
\\[3mm]
To collect the gas price history, the transaction history is queried at each hour since Uniswap migrated to V3. This is because querying in the same as the pricing data and borrowing rate history is too exhaustive as transactions occur every second. Therefore, it is more efficient to query at each hour with a window to retrieve the gas price at the closest hour as follows. Algorithm \ref{alg_gas_price_col} in the Appendix shows the pseudocode gas price at each hour is queried. 
\subsection{Types of Orders and Execution}
There are numerous order types that the backtesting supports due to measures to enusre a positive balance and avoid liquidation. The types of orders are; \texttt{BUY\ ETH}, \texttt{WITHDRAW}, \texttt{DEPOSIT}, \texttt{SWAP}, \texttt{OPEN\ BUY}, \texttt{CLOSE\ BUY}, \texttt{OPEN\ SELL}, \texttt{CLOSE\ SELL}. The precedures of each are outlined below.  The code of the execution, excluding gas fees, of the order is outlined in Appendix \ref{sec:backtesting-execution-code}.

\subsubsection{\texttt{BUY\ ETH}}
The \texttt{BUY\ ETH} order is used to swap a percentage of the accounts balance from WETH to ETH. The arguments is an float between 0 and 1.

\subsubsection{\texttt{SWAP}}
The \texttt{SWAP} order is to execute a simple swap for either token0 or token1 of the liquidity pool. This order is only used as a precautionary order, if the balance of the WETH balance gets too low. It takes 2 arguments, the first indicating whether it is swapping for token0 or token1 and the second parameter is a list of swaps, tuples containing with pool and the quantity, that would like to be swapped. The amount received in the account is multiplied by \texttt{(1 - swap\_fees[swap\_token])}, this is because Uniswap charges a percentage of the swap specified by \texttt{swap\_fees[swap\_token]}.

\subsubsection{\texttt{OPEN\ BUY}}
Similar to the \texttt{SWAP} order, \texttt{OPEN\ BUY} opens a buy position. As mentioned above opening a buy order is simply swapping token1 for token0. The parameters of buying are the target token and the volume. 

\subsubsection{\texttt{CLOSE\ BUY}}
Closing a buy position is similar to opening a buy position, however, the swap is in the other direction, i.e. from token to WETH. The only argument is the id of the buy order. To account for Uniswap's fees, the volume that was received, after the initial swap, is calculated then this volume is swapped back to WETH.

\subsubsection{\texttt{OPEN\ SELL}}
Opening a sell position involves borrowing a token and then swapping the token. The parameters of selling are the target token and the volume. It also consists of depositing the required amount to borrow the volume ordered, calculated by the value to loan ratio.

\subsubsection{\texttt{CLOSE\ SELL}}
Closing a sell position is more complicated that as in requires to swap back from the token to WETH, repay the loan with interest and finally return collateral. Swapping back to the required amount of tokens is the first step. For this the variable Annual Yield Rates between the timestamp of the opening of the position and closing positon is used to calculate the amount of interest required to be paid as this is cumulated every second. Once the volume of tokens required to be returned is calculated, the equivelent amount of WETH plus accounting for Uniswap fees is swapped to obtain these tokens. Finally, the tokens are repayed and the collateral is returned.

\subsubsection{\texttt{WITHDRAW}}
The \texttt{WITHDRAW} order's function is to withdraw some collateral that is stored in Aave. It is not used in the strategies however is implemented in case of developing further strategies that may require this functionality. The only parameter is the amount that would like to be withdrawn.

\subsubsection{\texttt{DEPOSIT}}
The \texttt{DEPOSIT} order's function is to deposit some additional collateral that is stored in Aave. This order is used when the collateral value not properly covering the loan value, hence avoiding liquidation. The only parameter is the amount that would like to be depositted. 

\subsection{Gas Fees}
The remaining fee that is yet to be discussed is gas fees of each order. To best approximate the gas fee it is paramount to have an approximation to how much gas is used in each. Therefore, the smart contract for trading was written and run on a forked Ethereum mainnet, to be able to accurately simulate the contracts behaviour, see Subsection \ref{sec:smart-contracts} to see the implementation of the smart contract. Using Hardhat, the gas usage of each function was tested and Figure \ref{fig:gasResult} shows the results. It can be seen that some functions have a tighter spread, between the maximum and minimum, compared to others therefore to better understand this, plots of using various parameters on the different functions provided a deeper insight into the cause of this, Figures \ref{fig:gasPlots1} and \ref{fig:gasPlots2}.
\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{project/Images/gas_fee_results.png}
    \caption{Results from running smart contract functions \label{fig:gasResult}}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{project/Images/SwapFeesPlot.png}\\
    \includegraphics[width=0.9\textwidth]{project/Images/BorrowFees2.png}
    \caption{Gas Usage Plots of Gas Used by Swapping (Top) and Borrowing (Bottom) \label{fig:gasPlots1}}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.9\textwidth]{project/Images/RepayFees2.png}\\
    \includegraphics[width=0.9\textwidth]{project/Images/depositFeesPlot2.png}
    \caption{Gas Usage Plots of Gas Used by Repaying Borrowed Tokens (Top) and Depositting additional tokens (Bottom) \label{fig:gasPlots2}}
\end{figure}

\noindent Upon analyzing these plots, it becomes apparent that the majority of the functions exhibit a high level of consistency. However, it is noteworthy that for the smallest quantity tested, the gas consumption is significantly higher compared to that of larger quantities. Nevertheless, once this threshold is surpassed, the gas usage remains consistent. Therefore the average of the gas usage of each operation is used in the backtesting system as it provides a representative estimate of the gas consumption across different quantities.
\\[3mm]
Furthermore, another feature that is interesting is the gas usage by swaps and the different methods. The initial method utilizes Uniswap's Router, which scans all available liquidity pools to identify the optimal price, whereas the second method involves direct swapping within a specific liquidity pool. Figure \ref{fig:gasPlots1} illustrates that, on average, the router-based approach exhibits higher gas usage compared to direct swapping using a liquidity pool. However, directly swapping using a liquidity pool exhibits greater volatility in terms of gas consumption but also consistently returns to values above 100,000, because of this the average gas usage of swapping using a liquidity pool is used.
\\[3mm]
It can also be seen that combining the operations to open/close buy and sell positions consumes less gas compared to if were to be executed seperately. This also confirms the claims in Wang's paper, that batching the operations together is more effective than executing them seperately~\cite{wang_cyclic_2022}.
\\[3mm]
To implement this in the backtesting system, each order deducts some ETH where this quantity is calculated by how much gas is used by the order type multiplied by the gas price. For example, in the case of buying more ETH:
\begin{lstlisting}[language=Python]
amount_to_swap = self.account['WETH'] * order[1]
self.account['WETH'] = self.account['WETH'] - amount_to_swap
self.account['ETH'] = self.account['ETH'] + amount_to_swap - (GAS_USED_BY_BUYING_ETH * gas_price_in_eth)
\end{lstlisting}
\vspace{5mm}
\noindent However, in order to analyze the impact of combining operations on strategy returns, the deduction of ETH for gas fees for both \texttt{OPEN} and \texttt{CLOSE} orders is handled differently. Instead of deducting the fees immediately upon each order, the deduction is performed after iterating through the trading signal. If the signal contains such orders, the necessary amount of gas fee is deducted based on whether the orders are specified, by the parameter \texttt{should\_batch\_trade}, to be batched or executed separately. The code for how this has been handled can be seen in Appendix \ref{app:deducting-gas-fee}.

\subsection{Validating Balance Health}
To maintain the integrity and effectiveness of the trading strategy, it is crucial to incorporate various checks and safeguards after each trade and at each timestep. One key aspect involves monitoring the balance of each token to ensure that it remains positive. After every order execution, the balances of the tokens involved are checked, and if any of them fall below zero, an exception is triggered.
\begin{lstlisting}[language=Python]
if self.account['T1'] < negative_threshold:
    raise Exception('Account balace goes below 0 - T1')
if self.account['T2'] < negative_threshold:
    raise Exception('Account balace goes below 0 - T2')
if self.account['WETH'] < negative_threshold:
    raise Exception('Account balace goes below 0 - WETH')
if self.account['ETH'] < negative_threshold:
    raise Exception('Account balace goes below 0 - ETH')
\end{lstlisting}   
Furthermore, to simulate the potential liquidation of a sell position's loan, the loan-to-value ratio is calculated. This ratio serves as an indicator of the position's health and risk level. If the loan-to-value ratio breaches the predefined liquidation threshold, indicating that the position is approaching an unsustainable state, an exception is thrown.
\begin{lstlisting}[language=Python]
sell_token, sold_price, sell_volume, _ = sell_trade
current_token_price = prices[f'P{sell_token[1]}']
curr_value_of_loan_pct = (sell_volume * current_token_price) / self.account['collateral_WETH']
if round(curr_value_of_loan_pct, 4) > liquidation_threshold:
    raise Exception(f'Short position liquidated')
\end{lstlisting}

\section{Live Trading}
To run the strategies, a similar approach is required however the executions system and balance tracking is altered. For the system there are multiple components that are required for live trading to occur. The first is the ability to interact with the blockchain to execute the orders, this is done by smart contracts, the second is to manage the state of the strategy, accounts and the open positions for the stratgies to use to generate signals and finally a method to convert the signal into smart contract invokations to execute the orders. The workflow of trading on the live executiom system.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{project/Images/live-trading-system-diagram.png}
    \caption{Flowchart of trading a strategy live \label{fig:live-flow}}
\end{figure}

\subsection{Smart Contracts}
\label{sec:smart-contracts}
In order to be able to interact with uniswap and aave over ethereum, smart contracts are written, which are then deployed on the blockchain network. Functions that the smart contract posseses can then be executed with anyone that knows the address of the contract on the network. Smart contracts are programmable protocols that are written in Solidity, a high-level programming language designed for creating and executing smart contracts on Ethereum. For the purpose of trading using the aforementioned strategies, a few the following functionalities are required to be implemented; wrapping ETH for WETH, unwrapping WETH, swapping token A for token B using a given liquidity pool and finally borrowing and repaying some of token A using WETH as collateral. The first 2 functions are required if the trader has only ETH in their account, thus by wrapping the ETH, they would be able to trade ETH as a ERC-20 token.

\subsubsection{Wrapping of ETH and Unwrapping WETH}
This functionality are required as if the trader has only ETH in their account, thus by wrapping the ETH, they would be able to trade ETH in it's ERC-20 token, WETH. ERC-20 is a widely adopted technical standard utilized for the creation of interchangeable tokens on the Ethereum blockchain. It provides developers with the framework to design tokens that are compatible with various applications and services operating within the Ethereum ecosystem. These tokens are designed to represent a variety of assets, most importantly cryptocurrencies. The functions of these functionalities can be seen below, where \texttt{swapEthForWeth} wraps ETH and \texttt{swapWethForEth} unwraps WETH. The \texttt{swapEthForWeth} function first uses the \texttt{IWETH} interface, which is itself an ERC20 interface, to allow functions such as tranfer of ownership of the token, to deposit an amount of ETH in exchange for WETH, which is then transfered back to the address of the caller. The \texttt{swapWethForEth} function unwraps the WETH by first sending the specified volume of WETH from the caller to the smart contract, withdrawing the specified amount from the IERC20, which calls the \texttt{receive} function to enable recieving of ETH and once the ETH is withdrawn into the smart contract's account, it is transfered back to the caller.
\begin{lstlisting}[language=Solidity]
interface IWETH is IERC20 {
  function deposit() external payable;
  function withdraw(uint amount) external;
}

address public immutable wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

function swapEthForWeth() external payable {
    IWETH weth = IWETH(wethAddress);
    weth.deposit{ value: msg.value }();
    weth.transfer(msg.sender, msg.value);
}

function swapWethForEth(uint256 amount) external payable {
    IWETH(wethAddress).transferFrom(msg.sender, address(this), amount);
    IWETH(wethAddress).withdraw(amount);
    msg.sender.transfer(address(this).balance);
}

receive() external payable {}
\end{lstlisting}

\subsubsection{Swapping using a Uniswap Liquidity Pool}
Swapping using a Uniswap liquidity pool is also another key functionality. This is done by using the \texttt{IUniswapV3Pool} interface to expose the liquidity pool's functions and calling swap on it using the necessary parameters. The parameters, in their respective order, are the address of the recipient of the swapped tokens, a boolean on whether the swap direction is from token0 to token1 or vice versa, the volume of the source token that would like to be swapped, an integer (sqrtPriceLimitX96) that manages how much slippage is acceptable, and finally abi encoded data that is used in the callback function. When calling \texttt{swap} function, the sqrtPriceLimitX96 parameter is set to ignore the effects of slippage and proceed with the swap. Finally, once the swap has taken place, Uniswap calls the callback function \texttt{uniswapV3SwapCallback} with transfers the swapped tokens to the caller of the function.

\begin{lstlisting}[language=Solidity]
function swapExactUsingPool(address poolAddress, bool zeroForOne, int256 amountIn) public returns (int256, int256) {
    IUniswapV3Pool pool = IUniswapV3Pool(poolAddress);
    return
        pool.swap(msg.sender, zeroForOne, amountIn, zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1, abi.encode(poolAddress, pool.token0(), pool.token1(), msg.sender));
}

function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external override {
    (address poolAddress, address token0, address token1, address userAddress) = abi.decode(data, (address, address, address, address));
    require(msg.sender == address(poolAddress));
    if (amount0Delta > 0) {
        IERC20(token0).transferFrom(
            userAddress,
            msg.sender,
            uint256(amount0Delta)
        );
    }
    if (amount1Delta > 0) {
        IERC20(token1).transferFrom(
            userAddress,
            msg.sender,
            uint256(amount1Delta)
        );
    }
}
\end{lstlisting}

\subsubsection{Borrowing and Repaying Tokens using Aave}
To allow for short selling, borrowing and repaying of tokens are required, therefore interacting with Aave in the smart contract is essential. The first step is to instantiate the lending pool using Aave's \texttt{PoolAddressesProvider}. When borrowing, some collateral is set aside in order to be able to borrow any number of tokens, thus the first step is to deposit this collateral into the lending pool and allow it to be used as collateral (Lines 1-8). Secondly, the specified token is borrowed from the lending pool using the variable interest rate, specified by the third argument in the \texttt{borrow} function, once received, the tokens are sent to the caller's address. The opposite methodology is true for the repayment of a loan, the tokens are transfered from the callers address to the smart contract's address which the sent back to the lending pool by the \texttt{repay} function and the collateral is withdrawn and automatically sent to the caller's address.
\begin{lstlisting}[language=Solidity]
IPool public immutable lendingPool = IPool(IPoolAddressesProvider(0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e).getPool());

function borrowToken(address tokenAddress, uint256 borrowAmount, uint256 collatoralAmount) public {
    // Deposit Collatoral
    IERC20(wethAddress).transferFrom(msg.sender, address(this), collatoralAmount);
    IERC20(wethAddress).approve(address(lendingPool), collatoralAmount);
    lendingPool.deposit(wethAddress, collatoralAmount, address(this), 0);
    lendingPool.setUserUseReserveAsCollateral(wethAddress, true);

    // Borrow token
    lendingPool.borrow(tokenAddress, borrowAmount, 2, 0, address(this));
    IERC20(tokenAddress).transferFrom(address(this), msg.sender, borrowAmount);
}

function repayBorrowedToken(address tokenAddress, uint256 repayAmount, uint256 collateralWithdrawAmount) public {
    IERC20(tokenAddress).transferFrom(msg.sender, address(this), repayAmount);
    IERC20(tokenAddress).approve(address(lendingPool), repayAmount);
    lendingPool.repay(tokenAddress, repayAmount, 2, address(this));
    lendingPool.withdraw(wethAddress, collateralWithdrawAmount, msg.sender);
}
\end{lstlisting}

\subsubsection{Opening and Closing of Trading Positions}
In addition to these functions, it is know that batching transactions together is more efficient than having to execute them separately, therefore as the strategies being explored for this project require both a buying and selling trade each time, the functions \texttt{openBuySellPositions} and \texttt{closeBuySellPositions} have been implemented such that it follows the method mentioned in Subsection \ref{sec:buying-selling}.

\begin{lstlisting}[language=Solidity]
function openBuySellPositions(address buyPoolAddress, bool buyZeroForOne, int256 buyAmount, address sellTokenAddress, uint256 sellAmount, uint256 collatoralAmount, address sellPoolAddress, bool sellZeroForOne) external {
        swapExactUsingPool(buyPoolAddress, buyZeroForOne, buyAmount);
        borrowToken(sellTokenAddress, sellAmount, collatoralAmount);
        swapExactUsingPool(sellPoolAddress, sellZeroForOne, int256(sellAmount));
}

function closeBuySellPositions(address buyPoolAddress, bool buyZeroForOne, int256 buyAmount, address sellTokenAddress, uint256 sellAmount, uint256 collatoralAmount, address sellPoolAddress, bool sellZeroForOne
    ) external {
        swapExactUsingPool(buyPoolAddress, buyZeroForOne, buyAmount);
        swapExactUsingPool(sellPoolAddress, sellZeroForOne, int256(sellAmount));
        repayBorrowedToken(sellTokenAddress, sellAmount, collatoralAmount);
}
\end{lstlisting}

\subsection{State}
Storing the state of the strategy is important as the strategies need to store and maintain it's history and vairables to ensure consistency when trading, therefore the state is stored as a dictionary in a pickle file. The State contains the liquidity pool pair that is being traded, the strategy instance, a dictionary of the open positions (initially empty) and the account balance. The state is updated after every exectution and is stored back into the pickle file.

\subsection{Retreival of Data and Signal Generation}
The frequency at which signals and data are collected is easily variable, however, to ensure consistency, the current design has a frequency of every hour. This frequency is set in a Cron job. The Cron job runs a script to collect the current price data and generate a signal. Using Uniswap's subgraph, 2 queries are sent to retrieve the necessary data. The first query queries the liquidity pool returning its current prices, the second, retrieves the most recent transaction, regardless of the type of transaction, to collect the cost of gas at the time. These data points are inserted into their corresponding tables in the database and are also sent to the strategy to generate a signal, which is sent to the execution system for execution. The GraphQL queries can be found in Appendix \ref{app:live-pool-price-query} and \ref{app:live-gas-query}.

\subsection{Trade Execution}
Once the signal has been received, it is sent to the trade exectution system. Once the signal is required to be actualized, the execution system breaks the signal into the different types of orders and executes them. For each type of order, its parameters are extracted, e.g. volume to buy, volume to sell, the target token and the prices in the case of opening a position. These parameters are then used to calculate the remaining paramters that are required to call the corresponding smart contract function, e.g. the swap direction's zeroForOne. Finally, once all of the necessary function parameters has been defined, the order is executed on the blockchain by performing 4 steps. The first is calling the smart contract function, signing the transaction, sending the transaction and waiting for the transaction to complete.
\begin{lstlisting}[language=Python]
# Call the order's corresponding function
call_function = contract.functions.<Smart Contract Function Name>(<Function Paramters>).buildTransaction({"chainId": Chain_id, "from": caller, "nonce": nonce})
# Sign transaction
signed_tx = web3.eth.account.sign_transaction(call_function, private_key=private_key)
# Send transaction
send_tx = web3.eth.send_raw_transaction(signed_tx.rawTransaction)
# Wait for transaction receipt
tx_receipt = web3.eth.wait_for_transaction_receipt(send_tx)
\end{lstlisting}

\noindent After all of the orders have been executed, the new balances of each token along with the updated \texttt{open\_positions} is returned to then be stored as the new state.

